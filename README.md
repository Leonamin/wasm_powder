# Wasm Powder Toy
웹어셈블리(WebAssembly)와 C++ 기반의 고성능 입자 시뮬레이션 게임

## 1. 팀 정보
| 역할 | 이름 | 학번 |
|------|------|------------|
| **팀장 / 백엔드** | 강은별 | 20252714 |
| **프론트엔드 / UI** | 김지민 | 20233600 |
| **게임 로직 / 물리** | 이승민 | 20251692 |

## 2. 프로젝트 개요 및 주요 기능
이 프로젝트는 웹 브라우저에서 실행되는 고성능 "파우더토이" 시뮬레이션 게임입니다. 자바스크립트만으로는 구현하기 어려운 대규모 셀룰러 오토마타 연산(120,000개 이상의 셀)을 **C++로 작성하고 WebAssembly(WASM)로 컴파일**하여 60FPS의 부드러운 성능을 달성했습니다.

### 주요 기능
-   **다양한 물질 구현:** 고체(모래, 벽), 액체(물, 기름), 기체(증기, CO2), 특수(불, 얼음) 등 다양한 상태의 물질을 시뮬레이션합니다.
-   **화학 반응 시스템:** 물질 간의 상호작용을 구현했습니다. (예: 불이 나무를 태움, 물이 불을 끔, 물이 얼어서 얼음이 됨)
-   **고성능 렌더링:** WASM 메모리에 직접 접근(Shared Memory)하여 데이터를 복사하는 오버헤드를 최소화했습니다.
-   **사용자 도구:** 브러시 크기/모양 조절, 온도 보기 모드 등 다양한 시각화 및 제어 기능을 제공합니다.

### 핵심 동작 원리: 셀룰러 오토마타 (Cellular Automata)
이 프로젝트의 핵심 기술인 **셀룰러 오토마타**는 바둑판 같은 격자(Grid) 위의 모든 칸들이 각자 자신의 주변 상황만 보고 정해진 규칙에 따라 다음 상태를 결정하는 알고리즘입니다.

1.  **세포(Cell)와 상태:** 화면의 픽셀 하나하나가 독립적인 세포이며, 고유의 상태(빈 공간, 모래, 물 등)를 가집니다.
2.  **국소적 규칙(Local Rules):** 중앙의 통제 없이, 각 세포가 "내 아래가 비었으면 내려간다"와 같은 단순한 규칙을 스스로 수행합니다.
3.  **연산량:** 400x300 해상도에서 120,000개의 세포가 초당 60번씩 상태를 갱신하므로, **초당 약 720만 번 이상의 연산**이 수행됩니다. 이 방대한 연산을 처리하기 위해 고성능 언어인 C++와 WebAssembly를 도입했습니다.

## 3. 실행 방법
이 프로젝트는 WebAssembly를 사용하므로 CORS 정책으로 인해 로컬 파일 열기로는 실행되지 않습니다.

1.  **사전 준비:** Python 3 또는 기타 웹 서버 구동 환경
2.  **서버 실행:**
    터미널에서 프로젝트의 `web` 폴더로 이동한 뒤 아래 명령어를 실행합니다.
    ```bash
    cd web
    python3 -m http.server 8000
    ```
3.  **접속:** 브라우저(Chrome 권장) 주소창에 `http://localhost:8000` 입력

## 4. 역할 분담
-   **1.** 프로젝트 아키텍처 설계, C++ 입자 시뮬레이션 코어 구현, 메모리 최적화.
-   **2.** 물리 엔진 구현(중력, 밀도 기반 이동 알고리즘), 화학 반응 시스템 설계.
-   **3.** 웹 프론트엔드 개발(Canvas 렌더링, UI), 사용자 입력 처리, 문서화.

## 5. 개발 중 어려웠던 점과 해결 방법

### A. 대규모 연산의 성능 한계
-   **문제:** 초기 자바스크립트 프로토타입에서는 입자가 1만 개만 넘어가도 프레임이 급격히 떨어지는 현상이 발생했습니다.
-   **해결:** 핵심 연산 로직을 C++로 이식하고 WASM으로 변환하여 성능을 약 10배 이상 향상시켰습니다. 또한, 움직임이 없는 구역은 연산에서 제외하는 **Chunk 시스템**을 도입하여 최적화했습니다.

### B. 복잡한 열역학 시스템의 불안정성
-   **문제:** 열 전도와 상태 변화(고체↔액체↔기체)를 동시에 시뮬레이션할 때, 무한 루프나 비현실적인 진동 현상이 발생하여 시뮬레이션이 멈추는 문제가 있었습니다.
-   **해결:** 프로젝트의 안정성을 위해 복잡한 열 전도 로직은 일시적으로 비활성화하고, 화학 반응과 물리적 움직임의 정확도에 집중하는 것으로 방향을 선회했습니다.

### C. 고체 입자가 액체에 밀리는 현상
-   **문제:** 얼음(고체) 위에 물(액체)을 부으면 물이 얼음을 밀어내고 자리를 차지하는 버그가 있었습니다.
-   **원인:** 이동 로직이 단순 밀도 비교(`Density(Water) > Density(Ice)`)로만 되어 있어, 물이 얼음보다 무거워서 자리를 바꾸는 현상이 발생했습니다.
-   **해결:** 이는 현재 '단일 밀도 모델'의 한계점임을 파악했습니다. 추후 고체를 '움직이는 고체'와 '고정된 고체'로 엄격히 구분하여 해결할 예정입니다.

## 6. 가산점 항목 (기술적 도전)
-   **WASM 기반 자체 엔진:** 기존 라이브러리 없이 C++로 엔진을 바닥부터 직접 구현했습니다.
-   **Zero-Copy 렌더링:** JS와 WASM 간의 데이터 전송 비용을 없애기 위해, JS가 WASM의 선형 메모리(Linear Memory) 힙을 직접 읽어서 캔버스에 그리는 고급 기법을 사용했습니다.

## 7. Latency 측정 테이블
예정

| 입자 수 | 평균 FPS | 프레임 타임 (ms) | 비고 |
|---------|----------|------------------|------|
|    | 60.0     | 0.4 ms           | 매우 원활 |


